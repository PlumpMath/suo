@
*     The compiler

;; The compiler performs the following passes
;;
;; - conversion to continuation-passing-style
;; - closure and argument conversion
;; - code generation

=
(directory /compiler)
(open /assembler /utils /base)

@
**    CPS data structures

;; The CPS data structure consists of 'values' and 'instructions'.  A
;; 'value' represents a storage location with a constant contents.  An
;; 'instruction' represents some action, such as creating a new
;; location and initializing it.
;;
;; Both instructions and values are represented as Scheme objects that
;; carry a cache of properties and maybe additional information.

;; Values
;;
;; - (var SYMBOL)
;;
;;   The variable named SYMBOL.
;;
;; - (quote OBJECT)
;;
;;   An arbitrary literal object, such as a number or a string.
;;
;; - (reg IDX)
;;
;;   The register with number IDX.  These only appear after register
;;   allocation.

;; Instructions
;;
;; - (app VALUE1 VALUES...)
;;
;;   Jumps to the function indicated by VALUE1, passing it VALUES as
;;   the arguments.
;;
;; - (set VAR VALUE)
;;
;;   Set VAR to VALUE.  This only appears before boxifying.
;;
;; - (fix ((SYMBOL1 (SYMBOLS) BODY)... ) CONT)
;;
;;   Introduces functions named SYMBOL1, expecting SYMBOLS as their
;;   arguments, with BODY as their body.
;;
;; - (primop OP (RESULTS...) (ARGUMENTS...) (CONTS...))
;;
;;   Represents the primitive operation indicated by OP, binding
;;   RESULTS (symbols) to values computed from the ARGUMENTS
;;   (cps-values) and continuing with one of the CONTS
;;   (cps-instructions).
;;
;; CPS structures are constant; when applying transformations, a new
;; structure is constructed.

-
(define-record cps-var name id)

(define-record cps-box var)

(define-record cps-app func args restp contp)

(define-record cps-func name args restp contp source parent-cont body)

(define-record cps-fix funcs cont objects)

(define-record cps-primop type results args conts)

@
**    Printing a CPS structure

-
(define (cps-render obj)
  (cond ((pair? obj)
	 (cons (cps-render (car obj))
	       (cps-render (cdr obj))))

	((record? obj)
	 (record-case obj
	  
	  ((cps-var name)
	   name)
	  
	  ((cps-quote value)
	   `(quote ,value))
	  
	  ((cps-reg idx)
	   idx)
	  
	  ((cps-app func args restp contp)
	   `(app ,(cps-render func)
		 ,@(map cps-render args)
		 ,restp ,contp))
	  
	  ((cps-fix funcs cont objects)
	   `(fix ,(map cps-render objects)
		 ,(map cps-render funcs)
		 ,(cps-render cont)))
	  
	  ((cps-func name args restp contp source parent-cont body)
	   `(,(cps-render name)
	     ,(map cps-render args)
	     ,restp ,contp
	     ,(cps-render parent-cont)
	     ,(cps-render body)))
	  
	  ((cps-primop type results args conts)
	   `(primop ,type
		    ,(map cps-render results)
		    ,(map cps-render args)
		    ,(map cps-render conts)))
	  (else
	   obj)))

	(else
	 obj)))

(define /compiler/cps-render cps-render)

(define (cps-print-val obj)
  (record-case obj
    ((cps-var name)
     (display name))
    ((cps-quote value)
     (display "'")
     (display value))
    ((cps-reg idx)
     (display idx))
    (else
     (display (cps-render obj)))))

(define (cps-print-stat obj indent)

  (define (nl)
    (newline)
    (do ((i 0 (1+ i)))
	((= i indent))
      (display " ")))

  (define (print-val-list vals restp)
    (display "(")
    (let loop ((v vals)
	       (first #t))
      (cond ((not (null? v))
	     (if (not first)
		 (display " "))
	     (if (and (null? (cdr v)) restp)
		 (display ". "))
	     (cps-print-val (car v))
	     (loop (cdr v) #f))))
    (display ")"))

  (record-case obj

    ((cps-app func args restp contp)
     (nl)
     (display "(app")
     (if restp
	 (display "*"))
     (if contp
	 (display "@"))
     (display " ")
     (cps-print-val func)
     (for-each (lambda (a)
		 (display " ")
		 (cps-print-val a))
	       args)
     (display ")"))
	  
    ((cps-func name args restp contp source parent-cont body)
     (nl)
     (cps-print-val name)
     (display " ")
     (print-val-list args restp)
     ;;(nl)
     ;;(write source)
     (cps-print-stat body (+ indent 6)))

    ((cps-fix funcs cont objects)
     (for-each (lambda (func)
		 (nl)
		 (display "[")
		 (if (cps-func-contp func)
		     (display "@"))
		 (cps-print-val (cps-func-name func))
		 (display " ")
		 (print-val-list (cps-func-args func) (cps-func-restp func))
		 ;;(nl)
		 ;;(write (cps-func-source func))
		 (cps-print-stat (cps-func-body func) (+ indent 4))
		 (display "]"))
	       funcs)
     (cond ((not (null? objects))
	    (nl)
	    (display "  ")
	    (display (cons 'func-objects (cps-render objects)))))
     (cps-print-stat cont (+ indent 2)))

    ((cps-primop type results args conts)
     (nl)
     (display "(prim ")
     (display type)
     (display " ")
     (print-val-list results #f)
     (display " ")
     (print-val-list args #f)
     (if (= (length conts) 1)
	 (begin
	   (display ")")
	   (cps-print-stat (car conts) indent))
	 (begin
	   (for-each (lambda (c)
		       (nl)
		       (display " (begin")
		       (cps-print-stat c (+ indent 3))
		       (display ")"))
		     conts)
	   (display ")"))))
    
    (else
     (nl)
     (display (cps-render obj)))))

(define (pk-cps . args)
  (apply pk (map cps-render args))
  (car (last-pair args)))

@
**    Genvar

-
(define genvar-counter 0)

(define (genvar)
  (set! genvar-counter (1+ genvar-counter))
  (cps-var (symbol-append 'v (number->string genvar-counter)) 
	   genvar-counter))

(define (genvars n)
  (map (lambda (i) (genvar)) (iota n)))

@
**    Code generation hooks for the compiler

-
(define-record box
  value)

;; Bind a box to RESULT, put VALUE into it and continue with CONT
;;
(define (cps-gen-box result value cont)
  (cps-primop 'record
	      (list result)
	      (list (cps-quote box@type) value)
	      (list cont)))

;; Bind the value in BOX to RESULT and continue with CONT
;;
(define (cps-gen-box-ref result box cont)
  (cps-primop 'record-ref
	      (list result)
	      (list box (cps-quote 0))
	      (list cont)))

;; Put VALUE into BOX and continue with CONT
;;
(define (cps-gen-box-set box value cont)
  (cps-primop 'record-set
	      (list (genvar))
	      (list box (cps-quote 0) value)
	      (list cont)))

;; If VALUE is true, continue with THEN, else with ELSE
;;
(define (cps-gen-if-eq a b then else)
  (cps-primop 'if-eq
	      '()
	      (list a b)
	      (list then else)))

;; Bind the value in VARIABLE to RESULT and continue with CONT
;;
(define (cps-gen-variable-ref result variable cont)
  (cps-primop 'record-ref
	      (list result)
	      (list variable (cps-quote 0))
	      (list cont)))

;; Put VALUE into VARIABLE and continue with CONT
;;
(define (cps-gen-variable-set variable value cont)
  (cps-primop 'record-set
	      (list (genvar))
	      (list variable (cps-quote 0) value)
	      (list cont)))

@
**    Parameters

-
(define-macro (define-param name)
  `(define ,name (make-parameter #f)))

(define-macro (with-param param-val . body)
  (let* ((param-exp (car param-val))
	 (value-exp (cadr param-val)))
    `(call-p ,param-exp ,value-exp (lambda () ,@body))))

@
**    Conversion into CPS

;; Mini-Scheme is a subset of Scheme that is straightforward to
;; translate into CPS.  Translation from Scheme into Mini-Scheme is
;; done via Scheme macros.
;;
;; Mini-Scheme has the following forms:
;;
;; - SYMBOL
;;
;; - LITERAL
;;
;; - (:quote OBJECT)
;;
;; - (:lambda ARGS BODY)
;;
;; - (:labels (((SYM ARGS...) BODY)...) BODY)
;;
;; - (:begin EXP...)
;;
;; - (:primitive TYPE RESULTS ARGS CONTS)
;;
;; - (:set SYMBOL EXP)
;;
;; - (FUNC ARGS)

-
(define cps-source (make-parameter #f))
(define cps-parent-cont (make-parameter #f))

(define (cps-convert exp)

  (define (make-env) '())
  (define (extend-env sym value env) (acons sym value env))
  (define (lookup-env-symbol name env) (and (symbol? name) (assq-ref env name)))
  (define (extend-env* syms vals env)
    (if (null? syms)
	env
	(extend-env* (cdr syms) (cdr vals)
		     (extend-env (car syms) (car vals) env))))

  (define (bound-variable? val) (cps-var? val))

  (define (lookup-macro-transformer name env)
    (and (not (lookup-env-symbol name env))
	 (macro-transformer-lookup name)))

  (define (lookup-variable name env)
    (or (lookup-env-symbol name env)
	(variable-lookup name)))
  
  (define (lookup-function name env)
    (or (lookup-env-symbol name env)
	(function-lookup name)))

  (define (lookup-thing name env)
    (or (lookup-env-symbol name env)
	(lookup* name #t #t)))

  (define (conv-func func-label args body env)
    (let* ((cont-arg (genvar))
	   (restp (dotted-list? args))
	   (flat-args (flatten-dotted-list args))
	   (arg-vars (map (lambda (a)
			    (or (symbol? a)
				(error "argument names must be symbols: " a))
			    (or (not (symbol-absolute? a))
				(error "argument names must be relative: " a))
			    (genvar))
			  flat-args))
	   (body-env (extend-env* flat-args arg-vars env)))
      (cps-func func-label
		(cons* cont-arg arg-vars)
		restp #f
		(cps-source) (cps-quote #f)
		(with-param (cps-parent-cont cont-arg)
		  (conv (cons :begin body)
			body-env
			(lambda (z)
			  (cps-app cont-arg (list z) #f #t)))))))

  (define (is-tail-call? obj result-var)
    ;; must be of the form (app K (result-var) #f)
    (and ;; #f
	 (cps-app? obj)
	 (= 1 (length (cps-app-args obj)))
	 (eq? result-var
	      (car (cps-app-args obj)))
	 (not (cps-app-restp obj))))
  
  (define (tail-call-cont obj)
    (cps-app-func obj))
    
  (define (make-cont source env c z)
    (let* ((cont-label (genvar))
	   (result-var (genvar))
	   (cont-body (c result-var)))
      (if (is-tail-call? cont-body result-var)
	  (z (tail-call-cont cont-body))
	  (cps-fix (list (cps-func cont-label
				   (list result-var)
				   #f #t
				   source
				   (cps-parent-cont)
				   cont-body))
		   (z cont-label)
		   '()))))
	  
  (define (conv-apply func args restp env c)
    (let ((source (cps-source)))
      (conv* args env
	     (lambda (z-args)
	       (conv func env
		     (lambda (z-func)
		       (make-cont source env c
				  (lambda (z-cont)
				    (cps-app z-func
					     (cons* z-cont z-args)
					     restp #f)))))))))

  (define (conv-call-v producer consumer env c)
    (let ((source (cps-source)))
      (conv producer env
	    (lambda (z-producer)
	      (conv consumer env
		    (lambda (z-consumer)
		      (make-cont
		       source env c
		       (lambda (z-cont)
			 (let ((producer-cont (genvar))
			       (results (genvar)))
			   (cps-fix (list (cps-func producer-cont
						    (list results)
						    #t #t
						    'call-v z-cont
						    (cps-app z-consumer
							     (list z-cont
								   results)
							     #t #f)))
				    (cps-app z-producer
					     (list producer-cont)
					     #f #f)
				    '()))))))))))

  (define (conv-call-cc func env c)
    (let ((source (cps-source))
	  (cont-func-label (genvar))
	  (cont-func-cont (genvar))
	  (cont-func-args (genvar)))
      (conv func env
	    (lambda (z-func)
	      (make-cont source env c
			 (lambda (z-cont)
			   (cps-fix (list (cps-func cont-func-label
						    (list cont-func-cont
							  cont-func-args)
						    #t #f
						    'call-cc z-cont
						    (cps-app z-cont
							     (list
							      cont-func-args)
							     #t #t)))
				    (cps-app z-func
					     (list z-cont cont-func-label)
					     #f #f)
				    '())))))))

  (define (conv-primitive type results args conts env c)
    (let ((source (cps-source)))
      (let* ((result-vars (map (lambda (a) (genvar))
			       results))
	     (cont-env (extend-env* results result-vars env)))
	(conv* args env
	       (lambda (args-z)
		 (if (= (length conts) 1)
		     (cps-primop type
				 result-vars
				 args-z
				 (list (conv (car conts) cont-env c)))
		     (make-cont source env c
				(lambda (z-cont)
				  (let ((app-c (lambda (z)
						 (cps-app z-cont
							  (list z)
							  #f #t))))
				    (cps-primop 
				     type
				     result-vars
				     args-z
				     (map (lambda (cont)
					    (conv cont cont-env app-c))
					  conts)))))))))))

  ;; Apply C to a cps-value representing the result of evaluating EXP.
  ;; C should return a cps-instruction that consumes the cps-value.
  
  (define (conv exp env c)
    (conv1 #f exp env c))

  (define (conv-for-macro exp env c)
    (conv1 #t exp env c))

  (define (conv1 for-macro? exp env c)

    (with-param (cps-source (if for-macro?
				(cons exp (cps-source))
			      (list exp)))

      (pattern-case exp

	  ((:bootinfo)
	   (c (cps-quote bootinfo-marker)))

	  ((:define ?var ?val)
	   (error "wrong 'define' placement: " exp))
	  
	  ((:define-function ?var ?val)
	   (error "wrong 'define' placement: " exp))

	  ((:define-record-type ?var ?val)
	   (error "wrong 'define' placement: " exp))

	  ((:define-macro ?var ?val)
	   (error "wrong 'define' placement: " exp))

	  ((:quote ?val)
	   (c (cps-quote ?val)))
	  
	  ((:lambda ?args . ?body)
	   (let ((func (genvar)))
	     (cps-fix (list (conv-func func ?args ?body env))
		      (c func)
		      '())))
	  
	  ((:labels ?funcs . ?body)
	   (let* ((vars (map (lambda (f) (genvar)) ?funcs))
		  (env (extend-env* (map caar ?funcs) vars env))
		  (funcs (map (lambda (f v)
				(conv-func v (cdar f) (cdr f) env))
			      ?funcs vars)))
	     (cps-fix funcs
		      (conv (cons :begin
				  ?body)
			    env
			    c)
		      '())))

	  ((:let ?bindings . ?body)
	   (let* ((vars (map car ?bindings))
		  (exps (map cadr ?bindings)))
	     (conv* exps env
		    (lambda (zs)
		      (conv (cons :begin ?body)
			    (extend-env* vars zs env)
			    c)))))

	  ((:begin . ?body)
	   ;; XXX - allow multiple return values
	   (conv* ?body env
		  (lambda (zs)
		    (if (null? zs)
			(c (cps-quote (if #f #f)))
			(c (car (last-pair zs)))))))

	  ((:primitive ?type ?results ?args ?conts)
	   (conv-primitive ?type ?results ?args ?conts env c))

	  ((:letvar ?bindings . ?body)
	   (let* ((vars (map car ?bindings))
		  (exps (map cadr ?bindings)))
	     (conv* exps env
		    (lambda (zs)
		      (let* ((box-vars (map (lambda (v) (genvar)) vars))
			     (box-boxes (map cps-box box-vars)))
			(let loop ((bv box-vars)
				   (zs zs))
			  (cond ((null? bv)
				 (conv (cons :begin ?body)
				       (extend-env* vars box-boxes env)
				       c))
				(else
				 (cps-gen-box (car bv)
					      (car zs)
					      (loop (cdr bv)
						    (cdr zs)))))))))))
	   
	  ((:set ?var ?value)
	   (conv ?value
		 env
		 (lambda (z)
		   (let ((var (lookup-variable ?var env))
			 (cont (c (cps-quote (if #f #f)))))
		     (cond ((variable? var)
			    (cps-gen-variable-set (cps-quote var) z cont))
			   ((cps-box? var)
			    (cps-gen-box-set (cps-box-var var) z cont))
			   (else
			    (error "is a constant: " ?var)))))))

	  ((:call-cc ?func)
	   (conv-call-cc ?func env c))
	  
	  ((:call-v ?producer ?consumer)
	   (conv-call-v ?producer ?consumer env c))
	
	  ((:apply ?func . ?args)
	   (conv-apply ?func ?args #t env c))
	
	  ((?func . ?args)
	   (let ((transformer (and (symbol? ?func)
				   (lookup-macro-transformer ?func env))))
	     (if transformer
		 (conv-for-macro (apply transformer ?args) env c)
		 (conv-apply ?func ?args #f env c))))

	  (else
	   (if (symbol? exp)
	       (let ((thing (or (lookup-thing exp env)
				(lookup-function exp env))))
		 (cond ((or (cps-var? thing)
			    (cps-quote? thing))
			(c thing))
		       ((cps-box? thing)
			(let* ((result-var (genvar))
			       (cont (c result-var)))
			  (cps-gen-box-ref result-var (cps-box-var thing)
					   cont)))
		       ((variable? thing)
			(let* ((result-var (genvar))
			       (cont (c result-var)))
			  (cps-gen-variable-ref result-var (cps-quote thing)
						cont)))
		       ((macro? thing)
			(error "macro used as variable: " exp))
		       (else
			(c (cps-quote thing)))))
	       (c (cps-quote exp)))))))

  ;; Apply C to a list cps-values that represent the results of
  ;; evaluating EXPS, a list of expressions.  C should return a
  ;; cps-instruction that consumes the cps-values.
  ;; 
  ;; The generated cps-instructions will compute the EXPS in order.
  ;;
  (define (conv* exps env c)
    (if (null? exps)
	(c '())
	(conv (car exps) env
	      (lambda (car-z)
		(conv* (cdr exps) env
		       (lambda (cdr-z)
			 (c (cons car-z cdr-z))))))))

  (define (topfun cps)
    (if (and (cps-fix? cps)
	     (cps-primop? (cps-fix-cont cps))
	     (eq? 'bottom (cps-primop-type (cps-fix-cont cps))))
	cps
	(error "Can only compile lambdas")))

  (topfun (conv-for-macro exp (make-env)
			  (lambda (z)
			    (cps-primop 'bottom '() (list z) '())))))

@
**    Used, bound, free, and modified variables

-
(define (union* sets)
  (reduce union '() sets))

(define (map-union func list)
  (union* (map func list)))

(define (cps-used-vars cps)
  (record-case cps

    ((cps-var)
     (list cps))

    ((cps-quote val)
     '())

    ((cps-app func args restp contp)
     (union (cps-used-vars func)
	    (map-union cps-used-vars args)))

    ((cps-func label args restp contp source parent-cont body)
     (union (cps-used-vars parent-cont)
	    (cps-used-vars body)))

    ((cps-fix funcs cont objects)
     (union (cps-used-vars cont)
	    (map-union cps-used-vars funcs)))

    ((cps-primop type results args conts)
     (union (map-union cps-used-vars args)
	    (map-union cps-used-vars conts)))))

(define (cps-bound-vars cps)
  (record-case cps

    ((cps-var)
     '())

    ((cps-quote val)
     '())

    ((cps-app func args restp contp)
     '())

    ((cps-func label args restp contp source parent-cont body)
     (union (list label)
	    (union args
		   (cps-bound-vars body))))

    ((cps-fix funcs cont objects)
     (union (cps-bound-vars cont)
	    (map-union cps-bound-vars funcs)))

    ((cps-primop type results args conts)
     (union results
	    (map-union cps-bound-vars conts)))))

(define (cps-free-vars cps)
  (record-case cps

    ((cps-var)
     (list cps))

    ((cps-quote val)
     '())

    ((cps-app func args restp contp)
     (union (cps-used-vars func)
	    (map-union cps-used-vars args)))

    ((cps-func label args restp contp source parent-cont body)
     (set-difference (cps-free-vars body)
		     args))

    ((cps-fix funcs cont objects)
     (set-difference (union (cps-free-vars cont)
			    (map-union cps-free-vars funcs))
		     (union (map cps-func-name funcs)
			    objects)))

    ((cps-primop type results args conts)
     (set-difference (union (map-union cps-free-vars args)
			    (map-union cps-free-vars conts))
		     results))))
  
(define (cps-modified-vars cps)
  (record-case cps

    ((cps-var)
     '())

    ((cps-quote val)
     '())

    ((cps-app func args restp contp)
     '())

    ((cps-func label args restp contp source parent-cont body)
     (cps-modified-vars body))

    ((cps-fix funcs cont objects)
     (union (cps-modified-vars cont)
	    (map-union cps-modified-vars funcs)))

    ((cps-primop type results args conts)
     (map-union cps-modified-vars conts))))

(define (cps-count-nodes cps)
  (record-case cps

    ((cps-var)
     1)

    ((cps-quote val)
     1)

    ((cps-app func args restp contp)
     (+ 1 (cps-count-nodes func)
	(apply + (map cps-count-nodes args))))

    ((cps-func label args restp contp source parent-cont body)
     (+ 1 (cps-count-nodes parent-cont) (cps-count-nodes body)))

    ((cps-fix funcs cont objects)
     (+ 1 (cps-count-nodes cont)
	(apply + (map cps-count-nodes funcs))))

    ((cps-primop type results args conts)
     (+ 1
	(length results)
	(apply + (map cps-count-nodes args))
	(apply + (map cps-count-nodes conts))))))

@
**    Dynamic attributes

-
(define-macro (define-dynamic-attr name)
  (let ((parm-name (symbol-append name "@parm")))
    `(begin (define ,parm-name (make-parameter '()))
 	    (define (,name obj)
 	      (assq-ref (,parm-name) obj)))))

(define-macro (with-attr attr-obj-val . body)
  ;; attr-obj-val -> (attr obj val)
  (let* ((attr-name (car attr-obj-val))
	 (parm-name (symbol-append attr-name "@parm"))
	 (obj-exp (cadr attr-obj-val))
	 (val-exp (caddr attr-obj-val)))
    `(call-p ,parm-name (acons ,obj-exp ,val-exp (,parm-name))
	     (lambda () ,@body))))

(define (acons* keys vals lst)
  (cond ((null? keys)
	 lst)
	(else
	 (acons* (cdr keys) (cdr vals)
		 (acons (car keys) (car vals)
			lst)))))

(define-macro (with-attr* attr-objs-vals . body)
  ;; attr-objs-vals -> (attr objs vals)
  (let* ((attr-name (car attr-objs-vals))
	 (parm-name (symbol-append attr-name "@parm"))
	 (objs-exp (cadr attr-objs-vals))
	 (vals-exp (caddr attr-objs-vals)))
    `(call-p ,parm-name (acons* ,objs-exp ,vals-exp (,parm-name))
	     (lambda () ,@body))))

(define (make-cycle val)
  (let ((p (list val)))
    (set-cdr! p p)
    p))

(define-dynamic-attr cps-replacement)

@
** Lifting and merging fixes

A fix is lifted as high as possible (without crossing definitions of
variables that it uses) and is merged with other fixes on the way.
This merging helps the closure conversion pass to share closures
between multiple functions.
-

(define (cps-lift-and-merge-fixes cps)
  (record-case cps

    ((cps-var)
     cps)

    ((cps-quote val)
     cps)

    ((cps-app func args restp contp)
     cps)

    ((cps-func label args restp contp source parent-cont body)
     (cps-func label
	       args
	       restp
	       contp
	       source
	       parent-cont
	       (cps-lift-and-merge-fixes body)))

    ((cps-fix funcs cont objects)
     (let ((funcs (map cps-lift-and-merge-fixes funcs))
	   (cont (cps-lift-and-merge-fixes cont)))
       (if (cps-fix? cont)
	   ;; merge
	   (cps-fix (append funcs (cps-fix-funcs cont))
		    (cps-fix-cont cont)
		    '())
	   (cps-fix funcs
		    cont
		    objects))))

    ((cps-primop type results args conts)

     (define (func-used-vars fix)
       (map-union cps-used-vars (cps-fix-funcs fix)))

     (let* ((conts (map cps-lift-and-merge-fixes conts))
	    (lifted-conts-and-funcs
	     (map (lambda (c)
		    (if (and (cps-fix? c)
			     (null? (intersection results
						  (func-used-vars c))))
			(cons (cps-fix-cont c)
			      (cps-fix-funcs c))
			(cons c '())))
		  conts))
	    (lifted-conts (map car lifted-conts-and-funcs))
	    (lifted-funcs (apply append (map cdr lifted-conts-and-funcs)))
	    (new-p (cps-primop type
			       results
			       args
			       lifted-conts)))
       (if (null? lifted-funcs)
	   new-p
	   (cps-fix lifted-funcs
		    new-p
		    '()))))))

@
**    Calling convention 

This pass introduces the register-level calling convention into the
cps code.  This includes adding the arguments that will eventually be
used to pass the closed over variables to the functions, and creating
the records that represent user functions.

After this pass, the means for closing the functions are in
place (i.e., there are unused arguments), but the actual closing has
not been done (i.e., functions still have free variables).  The
subsequent "closing" pass will remove the free variables.  That pass
might need to run several times, and that's why the conversion to the
register-level calling convention has been split out into it's own
pass.

The calling convention differs between user functions, continuations,
and blocks.

Continuations:

 before:              A1 A2 .. AN
 after:   X1 X2 .. XN A1 A2 .. AN

Here, the Xi are the extra arguments that will be used to pass closed
over variables into the continuation.  There is always a fixed number
of them, cps-number-extra-args.  The Ai are the original arguments of
the continuation.  The Xi are analogous to 'callee-saved registers' in
stack-based calling conventions.  In 'leave' functions, they can be
passed to the continuation directly without touching them at all.
Continuations remain 'unwrapped'.  After code generation, they are
represented by a code object.

User functions:

 before:                C A1 A2 .. AN
 after:   X1 X2 .. XN Y C A1 A2 .. AN

Here, C is the continuation that should be called to deliver the
results of this function, and the Ai are the original arguments of the
function.  User functions are wrapped: after this pass, they will be
represented by a record object that points to a code object (and other
things).  The Xi are the extra arguments for C, and Y is the extra
argument for the user function itself, which will be used to pass the
record that represents this user function.  In addition to changing
the arguments of a user function as indicated above, all references to
it are replaced by references to its representing record.  This record
will contain places for the closed over variables.

Blocks have no calling convention; their arguments can be modified in
any way the compiler desires.  This pass does not modify them.

In addition to modifying the function definitions, function
applications need of course be adapted as well.

When calling a user function, the continuation passed to C is either
locally defined, or has been passed as an argument to some locally
defined user function.  In the former case, the application will use
the unspecified value for the Xi, in the latter case, it will use the
Xi that have been passed together with the continuation.  The record
object is used for Y and the actual object to be called is replaced
with the code object contained in that record object.  A type check
might be inserted as well.

A call to a continuation has the same two cases as a call to a user
functions: the continuation is either locally defined, in which case
we use the unspecified value for its Xi arguments, or it has been
passed to some locally defined user function, in which case the Xi
come from the arguments of that function.

-
(define cps-number-extra-args 1)

;; Of a var that holds a continuation: a list of values to use as its
;; extra arguments when calling it.
;;
(define-dynamic-attr cps-extra-args)

(define (cps-make-func-objects funcs func-objects cont)
  (cond ((null? funcs)
	 cont)
	((not (car func-objects))
	 (cps-make-func-objects (cdr funcs) (cdr func-objects) cont))
	(else 
	 (cps-primop 'function
		     (list (car func-objects))
		     (list (cps-func-name (car funcs))
			   (cps-quote (begin)))
		     (list (cps-make-func-objects
			    (cdr funcs) (cdr func-objects)
			    cont))))))

(define (cps-get-function-code result func-object cont)
  (if (not (cps-quote? func-object))
      (cps-primop 'if-function?
		  '()
		  (list func-object)
		  (list (cps-primop 'record-ref
				    (list result)
				    (list func-object (cps-quote 0))
				    (list cont))
			(cps-primop 'abort
				    '()
				    (list (cps-quote 4) func-object)
				    '())))
      (cps-primop 'record-ref
		  (list result)
		  (list func-object (cps-quote 0))
		  (list cont))))

(define (cps-calling-convention cps)
  (record-case cps

    ((cps-var)
     (or (cps-replacement cps) cps))

    ((cps-quote)
     cps)

    ((cps-app func args restp contp)
     (let ((args (map cps-calling-convention args)))
       (cond (contp
	      (cps-app func (append (cps-extra-args func) args)
		       restp contp))
	     ((cps-replacement func)
	      ;; a locally defined function, func is the code 
	      (cps-app func (append (cps-extra-args (car args))
				    (list (cps-replacement func))
				    args)
		       restp contp))
	     (else
	      ;; a function object, need to get the
	      ;; code from the function object.
	      (let ((code (genvar)))
		(cps-get-function-code
		 code func
		 (cps-app code 
			  (append (cps-extra-args (car args))
				  (list func)
				  args)
			  restp contp)))))))

    ((cps-func label args restp contp source parent-cont body)
     (let* ((conv-args (map cps-calling-convention args))
	    (new-args (if contp
			  (append (genvars cps-number-extra-args)
				  conv-args)
			  (append (cps-extra-args (car args)) (genvars 1)
				  conv-args))))
	 (cps-func label
		   new-args
		   restp
		   contp
		   source
		   parent-cont
		   (cps-calling-convention body))))

    ((cps-fix funcs cont objects)
     (let ((conts (map (lambda (f)
			 (if (cps-func-contp f)
			     (cps-func-name f)
			     (car (cps-func-args f))))
		       funcs))
	   (extras (map (lambda (f)
			 (if (cps-func-contp f)
			     (map (lambda (i) (cps-quote (begin)))
				  (iota cps-number-extra-args))
			     (genvars cps-number-extra-args)))
			funcs))
	   (func-objects (map (lambda (f)
				(if (cps-func-contp f)
				    #f
				    (genvar)))
			      funcs)))
       (with-attr*
	(cps-extra-args conts extras)
	(with-attr*
	 (cps-replacement (map cps-func-name funcs) func-objects)
	 (cps-fix (map cps-calling-convention funcs)
		  (cps-make-func-objects
		   funcs func-objects
		   (cps-calling-convention cont))
		  (filter identity func-objects))))))

    ((cps-primop type results args conts)
     (cps-primop type 
		 results
		 (map cps-calling-convention args)
		 (map cps-calling-convention conts)))))

@
**    Closure conversion

This pass 'closes' all funtions so that they do not have any free
variables.  It does this by using the extra arguments introduced when
converting the code to the final calling convention.

It might be necessary to run this pass more than once since the
changes it makes might introduce new free variables into functions.
The process usually converges quite quickly.

Another complication is that mutually recursive functions might lead
to cyclic references in the function objects.

Functions are closed by creating a vector for each fix that collects
the values of the free variables of all functions defined in that fix.
This vector is introduced into the code in a pre-pass.  It is
installed in the function objects and passed with continuations, as
explained above.

-

(define-dynamic-attr cps-closure-vector)

(define (cps-introduce-closure-vector cps)
  (record-case cps

    ((cps-app func args restp contp)
     (if contp
	 cps
	 (let* ((cont (list-ref args (1+ cps-number-extra-args)))
 		(cont-closure (cps-closure-vector cont)))
	   (cps-app func (cons (or cont-closure (car args))
			       (cdr args))
		    restp contp))))

    ((cps-func label args restp contp source parent-cont body)
     (cps-func label
	       args
	       restp
	       contp
	       source
	       parent-cont
	       (if contp
		   (cps-introduce-closure-vector body)
		   (let ((closure-vector (genvar)))
		     (cps-primop 'record-ref
				 (list closure-vector)
				 (list (list-ref args cps-number-extra-args)
				       (cps-quote 1))
				 (list (cps-introduce-closure-vector body)))))))

    ((cps-fix funcs cont objects)
     (let ((closure-vector (genvar)))
       (with-attr* (cps-closure-vector (map cps-func-name funcs)
				       (make-cycle closure-vector))
         (cps-fix (map cps-introduce-closure-vector funcs)
		  (cps-primop 'vector
			      (list closure-vector)
			      (list)
			      (list
			       (cps-introduce-closure-vector cont)))
		  (cons closure-vector objects)))))

    ((cps-primop type results args conts)
     (cps-primop type 
		 results
		 (if (eq? type 'function)
		     (list (car args) (cps-closure-vector (car args)))
		     args)
		 (map cps-introduce-closure-vector conts)))))

(define (cps-fix-closure-vector fix)
  (car (cps-primop-results (car (cps-fix-cont fix)))))

(define (cps-func-closure-vector func)
  (if (cps-func-contp func)
      (car (cps-func-args func))
      (car (cps-primop-results (cps-func-body func)))))

(define-dynamic-attr cps-closure-vector-index)

(define (cps-close-functions cps)
  (record-case cps
	       
    ((cps-var)
     (or (cps-replacement cps) cps))

    ((cps-quote)
     cps)
    
    ((cps-app func args restp contp)
     (cps-app (cps-close-functions func) (map cps-close-functions args)
	      restp contp))

    ((cps-fix funcs cont objects)
     (let* ((closure-vector-cps (cps-fix-cont cps))
	    (closure-vector (car (cps-primop-results closure-vector-cps)))
	    (base-index (length (cps-primop-args closure-vector-cps)))
	    (free-vars (map-union cps-free-vars funcs))
	    (indices (map (lambda (i) (+ i base-index))
			  (iota (length free-vars)))))

       (define (close-func func)
	 (let* ((closure-vector (cps-func-closure-vector func))
		(func-body (if (cps-func-contp func)
			       (cps-func-body func)
			       (car (cps-primop-conts (cps-func-body func)))))
		(func-preamble (if (cps-func-contp func)
				   #f
				   (cps-func-body func)))
		(free-vars (cps-free-vars func))
		(local-vars (genvars (length free-vars))))
	   
	   ;; (pk-cps (cps-func-name func) 'free free-vars)

	   (let loop ((vars free-vars)
		      (locals local-vars)
		      (body (with-attr* (cps-replacement free-vars local-vars)
					(cps-close-functions func-body))))
	     (cond ((null? vars)
		    (cps-func (cps-func-name func)
			      (cps-func-args func)
			      (cps-func-restp func)
			      (cps-func-contp func)
			      (cps-func-source func)
			      (cps-func-parent-cont func)
			      (if func-preamble
				  (cps-primop 
				   (cps-primop-type func-preamble)
				   (cps-primop-results func-preamble)
				   (cps-primop-args func-preamble)
				   (list body))
				  body)))
		   (else
		    (loop (cdr vars) (cdr locals)
			  (cps-primop 'vector-ref 
				      (list (car locals))
				      (list closure-vector
					    (cps-quote
					     (cps-closure-vector-index
					      (car vars))))
				      (list body))))))))
       
       (if (not (null? free-vars))
 	   (pk-cps (map cps-func-name funcs) 'free free-vars))

       (with-attr* (cps-closure-vector-index free-vars indices)
         (cps-fix (map close-func funcs)
		  (cps-primop 'vector
			      (cps-primop-results closure-vector-cps)
			      (append (cps-primop-args closure-vector-cps)
				      (map cps-close-functions free-vars))
			      (map cps-close-functions
				   (cps-primop-conts closure-vector-cps)))
		  objects))))

    ((cps-primop type results args conts)
     (cps-primop type 
		 results
		 (map cps-close-functions args)
		 (map cps-close-functions conts)))))
    
(define (cps-closure-convert cps)
  (let ((vectored (cps-introduce-closure-vector cps)))
    (cps-dbg 'vectored vectored)
    (let ((closed-1 (cps-close-functions vectored)))
      (cps-dbg 'closed-1 closed-1)
      (let ((closed-2 (cps-close-functions closed-1)))
	(cps-dbg 'closed-2 closed-2)
	closed-2))))

@
**    Register allocation

This pass also checks for free variables and complains if it find
some.  This helps to spot bugs in the closure conversion phases.

-
(define-param cps-next-register)
(define-param cps-current-func)
(define-dynamic-attr cps-register-func)

(define (cps-register-allocate cps)

  (define (allocate-regs vars cont)
    (let loop ((idx (cps-next-register))
	       (regs '())
	       (funcs '())
	       (rest vars))
      (cond ((null? rest)
	     (with-param (cps-next-register idx)
	       (with-attr* (cps-replacement vars (reverse regs))
		 (with-attr* (cps-register-func vars (reverse funcs))
		   (cont)))))
	    (else
	     (loop (1+ idx)
		   (cons (cps-get-reg idx) regs)
		   (cons (cps-current-func) funcs)
		   (cdr rest))))))

  (record-case cps
   
    ((cps-var)
     (let ((reg (cps-replacement cps)))
       (if reg
	   (or (eq? (cps-register-func cps) (cps-current-func))
	       (error "still free: " (cps-render cps))))
       (or reg cps)))
    
    ((cps-quote)
     cps)
    
    ((cps-app func args restp contp)
     (cps-app (cps-register-allocate func)
	      (map cps-register-allocate args)
	      restp contp))
    
    ((cps-func label args restp contp source parent-cont body)
     (with-param (cps-next-register 1)
       (with-param (cps-current-func label)
         (allocate-regs args
			(lambda ()
			  (cps-func label
				    (map cps-register-allocate args)
				    restp contp
				    source parent-cont
				    (cps-register-allocate body)))))))
    
    ((cps-fix funcs cont objects)
     (cps-fix (map cps-register-allocate funcs)
	      (cps-register-allocate cont)
	      objects))

    ((cps-primop type results args conts)
     (allocate-regs results
		    (lambda ()
		      (cps-primop type 
				  (map cps-register-allocate results)
				  (map cps-register-allocate args)
				  (map cps-register-allocate conts)))))))

@
**    Code generation

;; Primops are directly turned into instructions, apps are compiled
;; into shuffle and go instructions and funs are done by recursing.
;; Very simple.

-
(define-param cps-asm-context)

(define (cps-alloc-size cps)
  
  (record-case cps

    ((cps-app func args restp contp)
     0)

    ((cps-fix funcs cont objects)
     (cps-alloc-size cont))

    ((cps-primop type results args conts)
     (let* ((size (cps-primitive-alloc-size type args)))
       (if (eq? size #t)
	   0
	   (+ size (apply max 0 (map cps-alloc-size conts))))))))

(define-param cps-need-alloc-check)

(define (cps-code-generate cps)

  (define (call-signature args restp)
    (+ (* 2 (length args)) (if restp -1 0)))

  (record-case cps

    ((cps-var)
     ;; refers to a function and its replacement is (cps-quote code)
     (cps-replacement cps))

    ((cps-reg)
     cps)

    ((cps-quote)
     cps)

    ((cps-app func args restp contp)
     (if (and (cps-quote? func) (not (cps-quote-value func)))
	 (cps-asm-panic (cps-asm-context))
	 (begin
	   (cps-asm-shuffle (cps-asm-context)
			    (append (list 
				     (cps-quote (call-signature args restp)))
				    (map cps-code-generate args)
				    (list (cps-code-generate func)))
			    (map cps-get-reg (iota (+ (length args) 2))))
	   (cps-asm-go (cps-asm-context) (cps-get-reg (+ (length args) 1))))))

    ((cps-func label args restp contp source parent-cont body)
     (let ((ctxt (cps-asm-make-context source)))
       (cps-asm-prologue ctxt
			 (call-signature args restp)
			 (cps-alloc-size body))
       (with-param (cps-asm-context ctxt)
         (cps-code-generate body))
       (cps-asm-finish ctxt)))

    ((cps-fix funcs cont objects)
     (let ((codes (map cps-code-generate funcs)))
       (with-attr* (cps-replacement (map cps-func-name funcs)
				    (map cps-quote codes))
		   (cps-code-generate cont))))

    ((cps-primop type results args conts)
     (let* ((ctxt (cps-asm-context))
	    (results (map cps-code-generate results))
	    (args (map cps-code-generate args))
	    (first-cont (if (null? conts) #f (car conts)))
	    (extra-conts (if (null? conts) '() (cdr conts)))
	    (extra-cont-labels (map (lambda (cont)
				      (cps-asm-make-label ctxt))
				    extra-conts))
	    (alloc-size (cps-primitive-alloc-size type args)))
       (cps-primitive-asm ctxt type results args extra-cont-labels)
       (cond (first-cont
	      (if (eq? alloc-size #t)
		  (cps-asm-alloc-check ctxt (cps-alloc-size first-cont) #f))
	      (cps-code-generate first-cont)))
       (for-each (lambda (cont label)
		   (cps-asm-def-label ctxt label)
		   (if (eq? alloc-size #t)
		       (cps-asm-alloc-check ctxt
					    (cps-alloc-size cont)
					    #f))
		   (cps-code-generate cont))
		 extra-conts extra-cont-labels)))))

@
**    Putting it together

-
(define /compiler/cps-verbose #f)

(define (cps-dbg tag cps)
  (cond (/compiler/cps-verbose
	 (pk tag)
	 (call-p current-output-port (current-debug-port)
		 (lambda ()
		   (cps-print-stat cps 0)
		   (newline))))))

(define (cps-compile cps)
  (cps-dbg 'cps cps)
  (let ((lifted (cps-lift-and-merge-fixes cps)))
    (cps-dbg 'lifted lifted)
    (let ((calls (cps-calling-convention lifted)))
      (cps-dbg 'calls calls)
      (let ((clos (cps-closure-convert calls)))
	(cps-dbg 'clos clos)
	(let ((regs (cps-register-allocate (car (cps-fix-funcs clos)))))
	  (cps-dbg 'regs regs)
	  (record closure@type
		  (cps-code-generate regs)
		  #()
		  #f
		  #f))))))

(define (cps-compile-1 cps)
  (with-error-handler (lambda (msg args)
			(pk 'ERROR msg args)
			(set! /compiler/cps-verbose #t)
			(cps-compile cps))
		      (lambda ()
			(cps-compile cps))))

;; Takes EXP and returns a new expression that has the same effect as
;; EXP when evaluated.

(define (/base/compile exp)
  (set! genvar-counter 0)
  (cps-source (list exp))
  (let ((exp (macroexpand exp)))
    (if (and (pair? exp) (eq? (car exp) :lambda))
	`(:quote ,(cps-compile (cps-convert exp)))
	exp)))

